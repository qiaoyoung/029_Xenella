
#import <Foundation/Foundation.h>

@interface UnhappyEverData : NSObject

+ (instancetype)sharedInstance;

@end

@implementation UnhappyEverData

//: AFNetworking
- (NSString *)componentEnvelopeReceiveData {
    /* static */ NSString *componentEnvelopeReceiveData = nil;
    if (!componentEnvelopeReceiveData) {
        Byte value[] = {12, 89, 10, 149, 126, 40, 75, 46, 251, 85, 154, 159, 167, 190, 205, 208, 200, 203, 196, 194, 199, 192, 203};
        componentEnvelopeReceiveData = [self StringFromUnhappyEverData:value];
    }
    return componentEnvelopeReceiveData;
}

//: Request failed: %@ (%ld)
- (NSString *)kEvidentCommentEvent {
    /* static */ NSString *kEvidentCommentEvent = nil;
    if (!kEvidentCommentEvent) {
        Byte value[] = {24, 99, 13, 88, 147, 67, 167, 175, 249, 226, 213, 27, 198, 181, 200, 212, 216, 200, 214, 215, 131, 201, 196, 204, 207, 200, 199, 157, 131, 136, 163, 131, 139, 136, 207, 199, 140, 203};
        kEvidentCommentEvent = [self StringFromUnhappyEverData:value];
    }
    return kEvidentCommentEvent;
}

//: application/x-plist
- (NSString *)spacingDeliverDevice {
    /* static */ NSString *spacingDeliverDevice = nil;
    if (!spacingDeliverDevice) {
        Byte value[] = {19, 47, 7, 230, 177, 66, 57, 144, 159, 159, 155, 152, 146, 144, 163, 152, 158, 157, 94, 167, 92, 159, 155, 152, 162, 163, 65};
        spacingDeliverDevice = [self StringFromUnhappyEverData:value];
    }
    return spacingDeliverDevice;
}

//: com.alamofire.serialization.response.error.response
- (NSString *)themeAverKey {
    /* static */ NSString *themeAverKey = nil;
    if (!themeAverKey) {
        Byte value[] = {51, 79, 7, 144, 92, 156, 166, 178, 190, 188, 125, 176, 187, 176, 188, 190, 181, 184, 193, 180, 125, 194, 180, 193, 184, 176, 187, 184, 201, 176, 195, 184, 190, 189, 125, 193, 180, 194, 191, 190, 189, 194, 180, 125, 180, 193, 193, 190, 193, 125, 193, 180, 194, 191, 190, 189, 194, 180, 119};
        themeAverKey = [self StringFromUnhappyEverData:value];
    }
    return themeAverKey;
}

//: image/x-icon
- (NSString *)k_placeLogger {
    /* static */ NSString *k_placeLogger = nil;
    if (!k_placeLogger) {
        Byte value[] = {12, 90, 12, 126, 253, 83, 121, 69, 103, 238, 217, 157, 195, 199, 187, 193, 191, 137, 210, 135, 195, 189, 201, 200, 91};
        k_placeLogger = [self StringFromUnhappyEverData:value];
    }
    return k_placeLogger;
}

//: image/gif
- (NSString *)coreWritingPreference {
    /* static */ NSString *coreWritingPreference = nil;
    if (!coreWritingPreference) {
        Byte value[] = {9, 72, 6, 92, 228, 181, 177, 181, 169, 175, 173, 119, 175, 177, 174, 155};
        coreWritingPreference = [self StringFromUnhappyEverData:value];
    }
    return coreWritingPreference;
}

//: image/tiff
- (NSString *)spacingThirdConfig {
    /* static */ NSString *spacingThirdConfig = nil;
    if (!spacingThirdConfig) {
        Byte value[] = {10, 92, 13, 148, 194, 107, 143, 74, 130, 107, 192, 183, 64, 197, 201, 189, 195, 193, 139, 208, 197, 194, 194, 142};
        spacingThirdConfig = [self StringFromUnhappyEverData:value];
    }
    return spacingThirdConfig;
}

//: image/x-xbitmap
- (NSString *)featureProtectionPreference {
    /* static */ NSString *featureProtectionPreference = nil;
    if (!featureProtectionPreference) {
        Byte value[] = {15, 26, 12, 234, 57, 219, 104, 110, 199, 197, 246, 127, 131, 135, 123, 129, 127, 73, 146, 71, 146, 124, 131, 142, 135, 123, 138, 155};
        featureProtectionPreference = [self StringFromUnhappyEverData:value];
    }
    return featureProtectionPreference;
}

//: image/x-win-bitmap
- (NSString *)kOpeningConfig {
    /* static */ NSString *kOpeningConfig = nil;
    if (!kOpeningConfig) {
        Byte value[] = {18, 48, 13, 202, 40, 23, 234, 36, 56, 96, 73, 234, 178, 153, 157, 145, 151, 149, 95, 168, 93, 167, 153, 158, 93, 146, 153, 164, 157, 145, 160, 157};
        kOpeningConfig = [self StringFromUnhappyEverData:value];
    }
    return kOpeningConfig;
}

- (Byte *)UnhappyEverDataToCache:(Byte *)data {
    int arkVerse = data[0];
    Byte souApply = data[1];
    int subconscious = data[2];
    for (int i = subconscious; i < subconscious + arkVerse; i++) {
        int value = data[i] - souApply;
        if (value < 0) {
            value += 256;
        }
        data[i] = value;
    }
    data[subconscious + arkVerse] = 0;
    return data + subconscious;
}

//: image/jpeg
- (NSString *)spacingListenId {
    /* static */ NSString *spacingListenId = nil;
    if (!spacingListenId) {
        Byte value[] = {10, 80, 10, 246, 28, 21, 254, 192, 102, 179, 185, 189, 177, 183, 181, 127, 186, 192, 181, 183, 142};
        spacingListenId = [self StringFromUnhappyEverData:value];
    }
    return spacingListenId;
}

//: image/ico
- (NSString *)kEonPath {
    /* static */ NSString *kEonPath = nil;
    if (!kEonPath) {
        Byte value[] = {9, 75, 4, 214, 180, 184, 172, 178, 176, 122, 180, 174, 186, 39};
        kEonPath = [self StringFromUnhappyEverData:value];
    }
    return kEonPath;
}

//: application/xml
- (NSString *)themeInstallConfig {
    /* static */ NSString *themeInstallConfig = nil;
    if (!themeInstallConfig) {
        Byte value[] = {15, 35, 11, 108, 111, 200, 97, 8, 84, 81, 43, 132, 147, 147, 143, 140, 134, 132, 151, 140, 146, 145, 82, 155, 144, 143, 113};
        themeInstallConfig = [self StringFromUnhappyEverData:value];
    }
    return themeInstallConfig;
}

//: com.alamofire.serialization.response.error.data
- (NSString *)k_fleeReekPath {
    /* static */ NSString *k_fleeReekPath = nil;
    if (!k_fleeReekPath) {
        Byte value[] = {47, 17, 6, 63, 47, 229, 116, 128, 126, 63, 114, 125, 114, 126, 128, 119, 122, 131, 118, 63, 132, 118, 131, 122, 114, 125, 122, 139, 114, 133, 122, 128, 127, 63, 131, 118, 132, 129, 128, 127, 132, 118, 63, 118, 131, 131, 128, 131, 63, 117, 114, 133, 114, 69};
        k_fleeReekPath = [self StringFromUnhappyEverData:value];
    }
    return k_fleeReekPath;
}

//: Request failed: unacceptable content-type: %@
- (NSString *)coreDentDevice {
    /* static */ NSString *coreDentDevice = nil;
    if (!coreDentDevice) {
        Byte value[] = {45, 53, 9, 87, 114, 214, 71, 177, 19, 135, 154, 166, 170, 154, 168, 169, 85, 155, 150, 158, 161, 154, 153, 111, 85, 170, 163, 150, 152, 152, 154, 165, 169, 150, 151, 161, 154, 85, 152, 164, 163, 169, 154, 163, 169, 98, 169, 174, 165, 154, 111, 85, 90, 117, 163};
        coreDentDevice = [self StringFromUnhappyEverData:value];
    }
    return coreDentDevice;
}

+ (instancetype)sharedInstance {
    static UnhappyEverData *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

//: text/json
- (NSString *)viewApologizePlatform {
    /* static */ NSString *viewApologizePlatform = nil;
    if (!viewApologizePlatform) {
        Byte value[] = {9, 35, 13, 83, 218, 12, 181, 56, 193, 220, 232, 201, 201, 151, 136, 155, 151, 82, 141, 150, 146, 145, 241};
        viewApologizePlatform = [self StringFromUnhappyEverData:value];
    }
    return viewApologizePlatform;
}

//: image/x-bmp
- (NSString *)layoutIndexAlert {
    /* static */ NSString *layoutIndexAlert = nil;
    if (!layoutIndexAlert) {
        Byte value[] = {11, 76, 12, 187, 221, 184, 243, 194, 3, 74, 181, 184, 181, 185, 173, 179, 177, 123, 196, 121, 174, 185, 188, 221};
        layoutIndexAlert = [self StringFromUnhappyEverData:value];
    }
    return layoutIndexAlert;
}

//: com.alamofire.error.serialization.response
- (NSString *)screenPlusKey {
    /* static */ NSString *screenPlusKey = nil;
    if (!screenPlusKey) {
        Byte value[] = {42, 75, 11, 176, 44, 134, 153, 195, 32, 64, 210, 174, 186, 184, 121, 172, 183, 172, 184, 186, 177, 180, 189, 176, 121, 176, 189, 189, 186, 189, 121, 190, 176, 189, 180, 172, 183, 180, 197, 172, 191, 180, 186, 185, 121, 189, 176, 190, 187, 186, 185, 190, 176, 148};
        screenPlusKey = [self StringFromUnhappyEverData:value];
    }
    return screenPlusKey;
}

//: text/xml
- (NSString *)coreFleeText {
    /* static */ NSString *coreFleeText = nil;
    if (!coreFleeText) {
        Byte value[] = {8, 86, 13, 200, 32, 96, 111, 23, 78, 90, 83, 184, 49, 202, 187, 206, 202, 133, 206, 195, 194, 164};
        coreFleeText = [self StringFromUnhappyEverData:value];
    }
    return coreFleeText;
}

//: application/json
- (NSString *)viewDestinationTimer {
    /* static */ NSString *viewDestinationTimer = nil;
    if (!viewDestinationTimer) {
        Byte value[] = {16, 61, 3, 158, 173, 173, 169, 166, 160, 158, 177, 166, 172, 171, 108, 167, 176, 172, 171, 243};
        viewDestinationTimer = [self StringFromUnhappyEverData:value];
    }
    return viewDestinationTimer;
}

//: text/javascript
- (NSString *)screenPlayLogger {
    /* static */ NSString *screenPlayLogger = nil;
    if (!screenPlayLogger) {
        Byte value[] = {15, 82, 8, 241, 60, 37, 200, 200, 198, 183, 202, 198, 129, 188, 179, 200, 179, 197, 181, 196, 187, 194, 198, 235};
        screenPlayLogger = [self StringFromUnhappyEverData:value];
    }
    return screenPlayLogger;
}

//: image/bmp
- (NSString *)widgetResEvent {
    /* static */ NSString *widgetResEvent = nil;
    if (!widgetResEvent) {
        Byte value[] = {9, 20, 13, 176, 34, 177, 134, 252, 112, 9, 179, 182, 213, 125, 129, 117, 123, 121, 67, 118, 129, 132, 120};
        widgetResEvent = [self StringFromUnhappyEverData:value];
    }
    return widgetResEvent;
}

- (NSString *)StringFromUnhappyEverData:(Byte *)data {
    return [NSString stringWithUTF8String:(char *)[self UnhappyEverDataToCache:data]];
}

@end

// __DEBUG__
// __CLOSE_PRINT__
// MethodSerialization.m
// Copyright (c) 2011â€“2016 Alamofire Software Foundation ( http://alamofire.org/ )
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// __M_A_C_R_O__
//: #import "AFURLResponseSerialization.h"
#import "MethodSerialization.h"
//: #import <TargetConditionals.h>
#import <TargetConditionals.h>
//: #import <UIKit/UIKit.h>
#import <UIKit/UIKit.h>
//: #import <CoreGraphics/CoreGraphics.h>
#import <CoreGraphics/CoreGraphics.h>
//: #import <UIKit/UIKit.h>
#import <UIKit/UIKit.h>

//: NSString * const AFURLResponseSerializationErrorDomain = @"com.alamofire.error.serialization.response";

NSString * const kKeepPolicySettings (NSString *value) {
    if (value) {
        return [value.lowercaseString stringByAppendingString:@"before"];
    }
    return  [[UnhappyEverData sharedInstance] screenPlusKey];
};
//: NSString * const AFNetworkingOperationFailingURLResponseErrorKey = @"com.alamofire.serialization.response.error.response";

NSString * const styleSecureConfig (NSString *value) {
    if (value) {
        return [value.lowercaseString stringByAppendingString:@"huge"];
    }
    return  [[UnhappyEverData sharedInstance] themeAverKey];
};
//: NSString * const AFNetworkingOperationFailingURLResponseDataErrorKey = @"com.alamofire.serialization.response.error.data";

NSString * const viewBetweenSaveDevice (NSString *value) {
    if (value) {
        return [value.uppercaseString stringByAppendingString:@"interaction"];
    }
    return  [[UnhappyEverData sharedInstance] k_fleeReekPath];
};

//: static NSError * AFErrorWithUnderlyingError(NSError *error, NSError *underlyingError) {
static NSError * errorEhBloomerTiming(NSError *error, NSError *underlyingError) {
    //: if (!error) {
    if (!error) {
        //: return underlyingError;
        return underlyingError;
    }

    //: if (!underlyingError || error.userInfo[NSUnderlyingErrorKey]) {
    if (!underlyingError || error.userInfo[NSUnderlyingErrorKey]) {
        //: return error;
        return error;
    }

    //: NSMutableDictionary *mutableUserInfo = [error.userInfo mutableCopy];
    NSMutableDictionary *mutableUserInfo = [error.userInfo mutableCopy];
    //: mutableUserInfo[NSUnderlyingErrorKey] = underlyingError;
    mutableUserInfo[NSUnderlyingErrorKey] = underlyingError;

    //: return [[NSError alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];
    return [[NSError alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];
}

//: static BOOL AFErrorOrUnderlyingErrorHasCodeInDomain(NSError *error, NSInteger code, NSString *domain) {
static BOOL singleDomain(NSError *error, NSInteger code, NSString *domain) {
    //: if ([error.domain isEqualToString:domain] && error.code == code) {
    if ([error.domain isEqualToString:domain] && error.code == code) {
        //: return YES;
        return YES;
    //: } else if (error.userInfo[NSUnderlyingErrorKey]) {
    } else if (error.userInfo[NSUnderlyingErrorKey]) {
        //: return AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[NSUnderlyingErrorKey], code, domain);
        return singleDomain(error.userInfo[NSUnderlyingErrorKey], code, domain);
    }

    //: return NO;
    return NO;
}

//: id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject, NSJSONReadingOptions readingOptions) {
id mediaValues(id JSONObject, NSJSONReadingOptions readingOptions) {
    //: if ([JSONObject isKindOfClass:[NSArray class]]) {
    if ([JSONObject isKindOfClass:[NSArray class]]) {
        //: NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];
        NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];
        //: for (id value in (NSArray *)JSONObject) {
        for (id value in (NSArray *)JSONObject) {
            //: if (![value isEqual:[NSNull null]]) {
            if (![value isEqual:[NSNull null]]) {
                //: [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];
                [mutableArray addObject:mediaValues(value, readingOptions)];
            }
        }

        //: return (readingOptions & NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];
        return (readingOptions & NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];
    //: } else if ([JSONObject isKindOfClass:[NSDictionary class]]) {
    } else if ([JSONObject isKindOfClass:[NSDictionary class]]) {
        //: NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];
        NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];
        //: for (id <NSCopying> key in [(NSDictionary *)JSONObject allKeys]) {
        for (id <NSCopying> key in [(NSDictionary *)JSONObject allKeys]) {
            //: id value = (NSDictionary *)JSONObject[key];
            id value = (NSDictionary *)JSONObject[key];
            //: if (!value || [value isEqual:[NSNull null]]) {
            if (!value || [value isEqual:[NSNull null]]) {
                //: [mutableDictionary removeObjectForKey:key];
                [mutableDictionary removeObjectForKey:key];
            //: } else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) {
            } else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) {
                //: mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);
                mutableDictionary[key] = mediaValues(value, readingOptions);
            }
        }

        //: return (readingOptions & NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];
        return (readingOptions & NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];
    }

    //: return JSONObject;
    return JSONObject;
}

//: @implementation AFHTTPResponseSerializer
@implementation ReaderVolume

//: #pragma mark -
#pragma mark -

//: - (BOOL)validateResponse:(NSHTTPURLResponse *)response
- (BOOL)error:(NSHTTPURLResponse *)response
                    //: data:(NSData *)data
                    duringData:(NSData *)data
                   //: error:(NSError * __autoreleasing *)error
                   folly:(NSError * __autoreleasing *)error
{
    //: BOOL responseIsValid = YES;
    BOOL responseIsValid = YES;
    //: NSError *validationError = nil;
    NSError *validationError = nil;

    //: if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
    if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
        //: if (self.acceptableContentTypes && ![self.acceptableContentTypes containsObject:[response MIMEType]] &&
        if (self.agreementInfossed && ![self.agreementInfossed containsObject:[response MIMEType]] &&
            //: !([response MIMEType] == nil && [data length] == 0)) {
            !([response MIMEType] == nil && [data length] == 0)) {

            //: if ([data length] > 0 && [response URL]) {
            if ([data length] > 0 && [response URL]) {
                //: NSMutableDictionary *mutableUserInfo = [@{
                NSMutableDictionary *mutableUserInfo = [@{
                                                          //: NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: unacceptable content-type: %@", @"AFNetworking", nil), [response MIMEType]],
                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable([[UnhappyEverData sharedInstance] coreDentDevice], [[UnhappyEverData sharedInstance] componentEnvelopeReceiveData], nil), [response MIMEType]],
                                                          //: NSURLErrorFailingURLErrorKey:[response URL],
                                                          NSURLErrorFailingURLErrorKey:[response URL],
                                                          //: AFNetworkingOperationFailingURLResponseErrorKey: response,
                                                          styleSecureConfig(nil): response,
                                                        //: } mutableCopy];
                                                        } mutableCopy];
                //: if (data) {
                if (data) {
                    //: mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
                    mutableUserInfo[viewBetweenSaveDevice(nil)] = data;
                }

                //: validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);
                validationError = errorEhBloomerTiming([NSError errorWithDomain:kKeepPolicySettings(nil) code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);
            }

            //: responseIsValid = NO;
            responseIsValid = NO;
        }

        //: if (self.acceptableStatusCodes && ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] && [response URL]) {
        if (self.pairForgetses && ![self.pairForgetses containsIndex:(NSUInteger)response.statusCode] && [response URL]) {
            //: NSMutableDictionary *mutableUserInfo = [@{
            NSMutableDictionary *mutableUserInfo = [@{
                                               //: NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: %@ (%ld)", @"AFNetworking", nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],
                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable([[UnhappyEverData sharedInstance] kEvidentCommentEvent], [[UnhappyEverData sharedInstance] componentEnvelopeReceiveData], nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],
                                               //: NSURLErrorFailingURLErrorKey:[response URL],
                                               NSURLErrorFailingURLErrorKey:[response URL],
                                               //: AFNetworkingOperationFailingURLResponseErrorKey: response,
                                               styleSecureConfig(nil): response,
                                       //: } mutableCopy];
                                       } mutableCopy];

            //: if (data) {
            if (data) {
                //: mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
                mutableUserInfo[viewBetweenSaveDevice(nil)] = data;
            }

            //: validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);
            validationError = errorEhBloomerTiming([NSError errorWithDomain:kKeepPolicySettings(nil) code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);

            //: responseIsValid = NO;
            responseIsValid = NO;
        }
    }

    //: if (error && !responseIsValid) {
    if (error && !responseIsValid) {
        //: *error = validationError;
        *error = validationError;
    }

    //: return responseIsValid;
    return responseIsValid;
}

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: self = [self init];
    self = [self init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableStatusCodes = [decoder decodeObjectOfClass:[NSIndexSet class] forKey:NSStringFromSelector(@selector(acceptableStatusCodes))];
    self.pairForgetses = [decoder decodeObjectOfClass:[NSIndexSet class] forKey:NSStringFromSelector(@selector(pairForgetses))];
    //: self.acceptableContentTypes = [decoder decodeObjectOfClass:[NSSet class] forKey:NSStringFromSelector(@selector(acceptableContentTypes))];
    self.agreementInfossed = [decoder decodeObjectOfClass:[NSSet class] forKey:NSStringFromSelector(@selector(agreementInfossed))];

    //: return self;
    return self;
}

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [coder encodeObject:self.acceptableStatusCodes forKey:NSStringFromSelector(@selector(acceptableStatusCodes))];
    [coder encodeObject:self.pairForgetses forKey:NSStringFromSelector(@selector(pairForgetses))];
    //: [coder encodeObject:self.acceptableContentTypes forKey:NSStringFromSelector(@selector(acceptableContentTypes))];
    [coder encodeObject:self.agreementInfossed forKey:NSStringFromSelector(@selector(agreementInfossed))];
}

//: #pragma mark - AFURLResponseSerialization
#pragma mark - MethodSerialization

//: - (id)responseObjectForResponse:(NSURLResponse *)response
- (id)allError:(NSURLResponse *)response
                           //: data:(NSData *)data
                           runningBucket:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          responseError:(NSError *__autoreleasing *)error
{
    //: [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];
    [self error:(NSHTTPURLResponse *)response duringData:data folly:error];

    //: return data;
    return data;
}

//: - (instancetype)init {
- (instancetype)init {
    //: self = [super init];
    self = [super init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];
    self.pairForgetses = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];
    //: self.acceptableContentTypes = nil;
    self.agreementInfossed = nil;

    //: return self;
    return self;
}

//: + (instancetype)serializer {
+ (instancetype)disk {
    //: return [[self alloc] init];
    return [[self alloc] init];
}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFHTTPResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
    ReaderVolume *serializer = [[[self class] allocWithZone:zone] init];
    //: serializer.acceptableStatusCodes = [self.acceptableStatusCodes copyWithZone:zone];
    serializer.pairForgetses = [self.pairForgetses copyWithZone:zone];
    //: serializer.acceptableContentTypes = [self.acceptableContentTypes copyWithZone:zone];
    serializer.agreementInfossed = [self.agreementInfossed copyWithZone:zone];

    //: return serializer;
    return serializer;
}

//: @end
@end

//: #pragma mark -
#pragma mark -

//: @implementation AFJSONResponseSerializer
@implementation TossResponseSerializer

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: self = [super initWithCoder:decoder];
    self = [super initWithCoder:decoder];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.readingOptions = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(readingOptions))] unsignedIntegerValue];
    self.resourcePerusing = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(resourcePerusing))] unsignedIntegerValue];
    //: self.removesKeysWithNullValues = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(removesKeysWithNullValues))] boolValue];
    self.fromTiping = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(fromTiping))] boolValue];

    //: return self;
    return self;
}

//: + (instancetype)serializer {
+ (instancetype)disk {
    //: return [self serializerWithReadingOptions:(NSJSONReadingOptions)0];
    return [self timeNumberervalOptions:(NSJSONReadingOptions)0];
}

//: #pragma mark - AFURLResponseSerialization
#pragma mark - MethodSerialization

//: - (id)responseObjectForResponse:(NSURLResponse *)response
- (id)allError:(NSURLResponse *)response
                           //: data:(NSData *)data
                           runningBucket:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          responseError:(NSError *__autoreleasing *)error
{
    //: if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (![self error:(NSHTTPURLResponse *)response duringData:data folly:error]) {
        //: if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        if (!error || singleDomain(*error, NSURLErrorCannotDecodeContentData, kKeepPolicySettings(nil))) {
            //: return nil;
            return nil;
        }
    }

    // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.
    // See https://github.com/rails/rails/issues/1742
    //: BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:" " length:1]];
    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:" " length:1]];

    //: if (data.length == 0 || isSpace) {
    if (data.length == 0 || isSpace) {
        //: return nil;
        return nil;
    }

    //: NSError *serializationError = nil;
    NSError *serializationError = nil;

    //: id responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&serializationError];
    id responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.resourcePerusing error:&serializationError];

    //: if (!responseObject)
    if (!responseObject)
    {
        //: if (error) {
        if (error) {
            //: *error = AFErrorWithUnderlyingError(serializationError, *error);
            *error = errorEhBloomerTiming(serializationError, *error);
        }
        //: return nil;
        return nil;
    }

    //: if (self.removesKeysWithNullValues) {
    if (self.fromTiping) {
        //: return AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);
        return mediaValues(responseObject, self.resourcePerusing);
    }

    //: return responseObject;
    return responseObject;
}

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [super encodeWithCoder:coder];
    [super encodeWithCoder:coder];

    //: [coder encodeObject:@(self.readingOptions) forKey:NSStringFromSelector(@selector(readingOptions))];
    [coder encodeObject:@(self.resourcePerusing) forKey:NSStringFromSelector(@selector(resourcePerusing))];
    //: [coder encodeObject:@(self.removesKeysWithNullValues) forKey:NSStringFromSelector(@selector(removesKeysWithNullValues))];
    [coder encodeObject:@(self.fromTiping) forKey:NSStringFromSelector(@selector(fromTiping))];
}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFJSONResponseSerializer *serializer = [super copyWithZone:zone];
    TossResponseSerializer *serializer = [super copyWithZone:zone];
    //: serializer.readingOptions = self.readingOptions;
    serializer.resourcePerusing = self.resourcePerusing;
    //: serializer.removesKeysWithNullValues = self.removesKeysWithNullValues;
    serializer.fromTiping = self.fromTiping;

    //: return serializer;
    return serializer;
}

//: + (instancetype)serializerWithReadingOptions:(NSJSONReadingOptions)readingOptions {
+ (instancetype)timeNumberervalOptions:(NSJSONReadingOptions)readingOptions {
    //: AFJSONResponseSerializer *serializer = [[self alloc] init];
    TossResponseSerializer *serializer = [[self alloc] init];
    //: serializer.readingOptions = readingOptions;
    serializer.resourcePerusing = readingOptions;

    //: return serializer;
    return serializer;
}

//: - (instancetype)init {
- (instancetype)init {
    //: self = [super init];
    self = [super init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/json", @"text/javascript", nil];
    self.agreementInfossed = [NSSet setWithObjects:[[UnhappyEverData sharedInstance] viewDestinationTimer], [[UnhappyEverData sharedInstance] viewApologizePlatform], [[UnhappyEverData sharedInstance] screenPlayLogger], nil];

    //: return self;
    return self;
}

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

//: @end
@end

//: #pragma mark -
#pragma mark -

//: @implementation AFXMLParserResponseSerializer
@implementation PullResponseSerializer

//: #pragma mark - AFURLResponseSerialization
#pragma mark - MethodSerialization

//: - (id)responseObjectForResponse:(NSHTTPURLResponse *)response
- (id)allError:(NSHTTPURLResponse *)response
                           //: data:(NSData *)data
                           runningBucket:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          responseError:(NSError *__autoreleasing *)error
{
    //: if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (![self error:(NSHTTPURLResponse *)response duringData:data folly:error]) {
        //: if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        if (!error || singleDomain(*error, NSURLErrorCannotDecodeContentData, kKeepPolicySettings(nil))) {
            //: return nil;
            return nil;
        }
    }

    //: return [[NSXMLParser alloc] initWithData:data];
    return [[NSXMLParser alloc] initWithData:data];
}

//: + (instancetype)serializer {
+ (instancetype)disk {
    //: AFXMLParserResponseSerializer *serializer = [[self alloc] init];
    PullResponseSerializer *serializer = [[self alloc] init];

    //: return serializer;
    return serializer;
}

//: - (instancetype)init {
- (instancetype)init {
    //: self = [super init];
    self = [super init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"application/xml", @"text/xml", nil];
    self.agreementInfossed = [[NSSet alloc] initWithObjects:[[UnhappyEverData sharedInstance] themeInstallConfig], [[UnhappyEverData sharedInstance] coreFleeText], nil];

    //: return self;
    return self;
}

//: @end
@end

//: #pragma mark -
#pragma mark -
//: #pragma mark -
#pragma mark -

//: @implementation AFPropertyListResponseSerializer
@implementation PropertyResponseSerializer

//: - (instancetype)init {
- (instancetype)init {
    //: self = [super init];
    self = [super init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"application/x-plist", nil];
    self.agreementInfossed = [[NSSet alloc] initWithObjects:[[UnhappyEverData sharedInstance] spacingDeliverDevice], nil];

    //: return self;
    return self;
}

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

- (NSPropertyListReadOptions)element:(NSPropertyListReadOptions)affiliated {
    //: OC_CUSTOM_PROPERTY_INJECT
    _affiliated = affiliated;
    return affiliated;
}

//: @end

- (void)setAffiliated:(NSPropertyListReadOptions)affiliated {
    //: OC_CUSTOM_PROPERTY_INJECT
    _affiliated = affiliated;
}

//: + (instancetype)serializerWithFormat:(NSPropertyListFormat)format
+ (instancetype)appropriate:(NSPropertyListFormat)format
                         //: readOptions:(NSPropertyListReadOptions)readOptions
                         chanceTo:(NSPropertyListReadOptions)readOptions
{
    //: AFPropertyListResponseSerializer *serializer = [[self alloc] init];
    PropertyResponseSerializer *serializer = [[self alloc] init];
    //: serializer.format = format;
    serializer.aspectOutsides = format;
    //: serializer.readOptions = readOptions;
    serializer.fragmentTabing = readOptions;

    //: return serializer;
    return serializer;
}

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [super encodeWithCoder:coder];
    [super encodeWithCoder:coder];

    //: [coder encodeObject:@(self.format) forKey:NSStringFromSelector(@selector(format))];
    [coder encodeObject:@(self.aspectOutsides) forKey:NSStringFromSelector(@selector(aspectOutsides))];
    //: [coder encodeObject:@(self.readOptions) forKey:NSStringFromSelector(@selector(readOptions))];
    [coder encodeObject:@([self element:self.fragmentTabing]) forKey:NSStringFromSelector(@selector(fragmentTabing))];
}

//: #pragma mark - AFURLResponseSerialization
#pragma mark - MethodSerialization

//: - (id)responseObjectForResponse:(NSURLResponse *)response
- (id)allError:(NSURLResponse *)response
                           //: data:(NSData *)data
                           runningBucket:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          responseError:(NSError *__autoreleasing *)error
{
    //: if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (![self error:(NSHTTPURLResponse *)response duringData:data folly:error]) {
        //: if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        if (!error || singleDomain(*error, NSURLErrorCannotDecodeContentData, kKeepPolicySettings(nil))) {
            //: return nil;
            return nil;
        }
    }

    //: if (!data) {
    if (!data) {
        //: return nil;
        return nil;
    }

    //: NSError *serializationError = nil;
    NSError *serializationError = nil;

    //: id responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.readOptions format:NULL error:&serializationError];
    id responseObject = [NSPropertyListSerialization propertyListWithData:data options:[self element:self.fragmentTabing] format:NULL error:&serializationError];

    //: if (!responseObject)
    if (!responseObject)
    {
        //: if (error) {
        if (error) {
            //: *error = AFErrorWithUnderlyingError(serializationError, *error);
            *error = errorEhBloomerTiming(serializationError, *error);
        }
        //: return nil;
        return nil;
    }

    //: return responseObject;
    return responseObject;
}

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: self = [super initWithCoder:decoder];
    self = [super initWithCoder:decoder];
	[self setAffiliated:_fragmentTabing];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.format = (NSPropertyListFormat)[[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(format))] unsignedIntegerValue];
    self.aspectOutsides = (NSPropertyListFormat)[[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(aspectOutsides))] unsignedIntegerValue];
	[self setAffiliated:_fragmentTabing];
    //: self.readOptions = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(readOptions))] unsignedIntegerValue];
    self.fragmentTabing = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(fragmentTabing))] unsignedIntegerValue];

    //: return self;
    return self;
}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFPropertyListResponseSerializer *serializer = [super copyWithZone:zone];
    PropertyResponseSerializer *serializer = [super copyWithZone:zone];
    //: serializer.format = self.format;
    serializer.aspectOutsides = self.aspectOutsides;
	[self setAffiliated:_fragmentTabing];
    //: serializer.readOptions = self.readOptions;
    serializer.fragmentTabing = self.fragmentTabing;

    //: return serializer;
    return serializer;
}

//: + (instancetype)serializer {
+ (instancetype)disk {
    //: return [self serializerWithFormat:NSPropertyListXMLFormat_v1_0 readOptions:0];
    return [self appropriate:NSPropertyListXMLFormat_v1_0 chanceTo:0];
}


@end

//: #pragma mark -
#pragma mark -





//: @interface UIImage (AFNetworkingSafeImageLoading)
@interface UIImage (Stub)
//: + (UIImage *)af_safeImageWithData:(NSData *)data;
+ (UIImage *)job:(NSData *)data;
//: @end
@end

//: static NSLock* imageLock = nil;
static NSLock* widgetTransmissionConfig = nil;

//: @implementation UIImage (AFNetworkingSafeImageLoading)
@implementation UIImage (Stub)

//: + (UIImage *)af_safeImageWithData:(NSData *)data {
+ (UIImage *)job:(NSData *)data {
    //: UIImage* image = nil;
    UIImage* image = nil;
    //: static dispatch_once_t onceToken;
    static dispatch_once_t onceToken;
    //: _dispatch_once(&onceToken, ^{
    _dispatch_once(&onceToken, ^{
        //: imageLock = [[NSLock alloc] init];
        widgetTransmissionConfig = [[NSLock alloc] init];
    //: });
    });

    //: [imageLock lock];
    [widgetTransmissionConfig lock];
    //: image = [UIImage imageWithData:data];
    image = [UIImage imageWithData:data];
    //: [imageLock unlock];
    [widgetTransmissionConfig unlock];
    //: return image;
    return image;
}

//: @end
@end

//: static UIImage * AFImageWithDataAtScale(NSData *data, CGFloat scale) {
static UIImage * secondInfo(NSData *data, CGFloat scale) {
    //: UIImage *image = [UIImage af_safeImageWithData:data];
    UIImage *image = [UIImage job:data];
    //: if (image.images) {
    if (image.images) {
        //: return image;
        return image;
    }

    //: return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];
    return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];
}

//: static UIImage * AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response, NSData *data, CGFloat scale) {
static UIImage * addressJoin(NSHTTPURLResponse *response, NSData *data, CGFloat scale) {
    //: if (!data || [data length] == 0) {
    if (!data || [data length] == 0) {
        //: return nil;
        return nil;
    }

    //: CGImageRef imageRef = NULL;
    CGImageRef imageRef = NULL;
    //: CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);
    CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);

    //: if ([response.MIMEType isEqualToString:@"image/png"]) {
    if ([response.MIMEType isEqualToString:@"image/png"]) {
        //: imageRef = CGImageCreateWithPNGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
        imageRef = CGImageCreateWithPNGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
    //: } else if ([response.MIMEType isEqualToString:@"image/jpeg"]) {
    } else if ([response.MIMEType isEqualToString:[[UnhappyEverData sharedInstance] spacingListenId]]) {
        //: imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
        imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);

        //: if (imageRef) {
        if (imageRef) {
            //: CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);
            CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);
            //: CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);
            CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);

            // CGImageCreateWithJPEGDataProvider does not properly handle CMKY, so fall back to AFImageWithDataAtScale
            //: if (imageColorSpaceModel == kCGColorSpaceModelCMYK) {
            if (imageColorSpaceModel == kCGColorSpaceModelCMYK) {
                //: CGImageRelease(imageRef);
                CGImageRelease(imageRef);
                //: imageRef = NULL;
                imageRef = NULL;
            }
        }
    }

    //: CGDataProviderRelease(dataProvider);
    CGDataProviderRelease(dataProvider);

    //: UIImage *image = AFImageWithDataAtScale(data, scale);
    UIImage *image = secondInfo(data, scale);
    //: if (!imageRef) {
    if (!imageRef) {
        //: if (image.images || !image) {
        if (image.images || !image) {
            //: return image;
            return image;
        }

        //: imageRef = CGImageCreateCopy([image CGImage]);
        imageRef = CGImageCreateCopy([image CGImage]);
        //: if (!imageRef) {
        if (!imageRef) {
            //: return nil;
            return nil;
        }
    }

    //: size_t width = CGImageGetWidth(imageRef);
    size_t width = CGImageGetWidth(imageRef);
    //: size_t height = CGImageGetHeight(imageRef);
    size_t height = CGImageGetHeight(imageRef);
    //: size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);
    size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);

    //: if (width * height > 1024 * 1024 || bitsPerComponent > 8) {
    if (width * height > 1024 * 1024 || bitsPerComponent > 8) {
        //: CGImageRelease(imageRef);
        CGImageRelease(imageRef);

        //: return image;
        return image;
    }

    // CGImageGetBytesPerRow() calculates incorrectly in iOS 5.0, so defer to CGBitmapContextCreate
    //: size_t bytesPerRow = 0;
    size_t bytesPerRow = 0;
    //: CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    //: CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);
    CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);
    //: CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);
    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);

    //: if (colorSpaceModel == kCGColorSpaceModelRGB) {
    if (colorSpaceModel == kCGColorSpaceModelRGB) {
        //: uint32_t alpha = (bitmapInfo & kCGBitmapAlphaInfoMask);
        uint32_t alpha = (bitmapInfo & kCGBitmapAlphaInfoMask);
//: #pragma clang diagnostic push
#pragma clang diagnostic push
//: #pragma clang diagnostic ignored "-Wassign-enum"
#pragma clang diagnostic ignored "-Wassign-enum"
        //: if (alpha == kCGImageAlphaNone) {
        if (alpha == kCGImageAlphaNone) {
            //: bitmapInfo &= ~kCGBitmapAlphaInfoMask;
            bitmapInfo &= ~kCGBitmapAlphaInfoMask;
            //: bitmapInfo |= kCGImageAlphaNoneSkipFirst;
            bitmapInfo |= kCGImageAlphaNoneSkipFirst;
        //: } else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) {
        } else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) {
            //: bitmapInfo &= ~kCGBitmapAlphaInfoMask;
            bitmapInfo &= ~kCGBitmapAlphaInfoMask;
            //: bitmapInfo |= kCGImageAlphaPremultipliedFirst;
            bitmapInfo |= kCGImageAlphaPremultipliedFirst;
        }
//: #pragma clang diagnostic pop
#pragma clang diagnostic pop
    }

    //: CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);

    //: CGColorSpaceRelease(colorSpace);
    CGColorSpaceRelease(colorSpace);

    //: if (!context) {
    if (!context) {
        //: CGImageRelease(imageRef);
        CGImageRelease(imageRef);

        //: return image;
        return image;
    }

    //: CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);
    CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);
    //: CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);
    CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);

    //: CGContextRelease(context);
    CGContextRelease(context);

    //: UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];
    UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];

    //: CGImageRelease(inflatedImageRef);
    CGImageRelease(inflatedImageRef);
    //: CGImageRelease(imageRef);
    CGImageRelease(imageRef);

    //: return inflatedImage;
    return inflatedImage;
}



//: @implementation AFImageResponseSerializer
@implementation ColleagueResponseSerializer

//: - (instancetype)init {
- (instancetype)init {
    //: self = [super init];
    self = [super init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"image/tiff", @"image/jpeg", @"image/gif", @"image/png", @"image/ico", @"image/x-icon", @"image/bmp", @"image/x-bmp", @"image/x-xbitmap", @"image/x-win-bitmap", nil];
    self.agreementInfossed = [[NSSet alloc] initWithObjects:[[UnhappyEverData sharedInstance] spacingThirdConfig], [[UnhappyEverData sharedInstance] spacingListenId], [[UnhappyEverData sharedInstance] coreWritingPreference], @"image/png", [[UnhappyEverData sharedInstance] kEonPath], [[UnhappyEverData sharedInstance] k_placeLogger], [[UnhappyEverData sharedInstance] widgetResEvent], [[UnhappyEverData sharedInstance] layoutIndexAlert], [[UnhappyEverData sharedInstance] featureProtectionPreference], [[UnhappyEverData sharedInstance] kOpeningConfig], nil];


    //: self.imageScale = [[UIScreen mainScreen] scale];
    self.tabDoed = [[UIScreen mainScreen] scale];
    //: self.automaticallyInflatesResponseImage = YES;
    self.volumeBorderred = YES;





    //: return self;
    return self;
}

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [super encodeWithCoder:coder];
    [super encodeWithCoder:coder];


    //: [coder encodeObject:@(self.imageScale) forKey:NSStringFromSelector(@selector(imageScale))];
    [coder encodeObject:@(self.tabDoed) forKey:NSStringFromSelector(@selector(tabDoed))];
    //: [coder encodeBool:self.automaticallyInflatesResponseImage forKey:NSStringFromSelector(@selector(automaticallyInflatesResponseImage))];
    [coder encodeBool:self.volumeBorderred forKey:NSStringFromSelector(@selector(volumeBorderred))];

}

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: self = [super initWithCoder:decoder];
    self = [super initWithCoder:decoder];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }


    //: NSNumber *imageScale = [decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(imageScale))];
    NSNumber *imageScale = [decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(tabDoed))];

    //: self.imageScale = [imageScale doubleValue];
    self.tabDoed = [imageScale doubleValue];




    //: self.automaticallyInflatesResponseImage = [decoder decodeBoolForKey:NSStringFromSelector(@selector(automaticallyInflatesResponseImage))];
    self.volumeBorderred = [decoder decodeBoolForKey:NSStringFromSelector(@selector(volumeBorderred))];


    //: return self;
    return self;
}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFImageResponseSerializer *serializer = [super copyWithZone:zone];
    ColleagueResponseSerializer *serializer = [super copyWithZone:zone];


    //: serializer.imageScale = self.imageScale;
    serializer.tabDoed = self.tabDoed;
    //: serializer.automaticallyInflatesResponseImage = self.automaticallyInflatesResponseImage;
    serializer.volumeBorderred = self.volumeBorderred;


    //: return serializer;
    return serializer;
}

//: #pragma mark - AFURLResponseSerializer
#pragma mark - AFURLResponseSerializer

//: - (id)responseObjectForResponse:(NSURLResponse *)response
- (id)allError:(NSURLResponse *)response
                           //: data:(NSData *)data
                           runningBucket:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          responseError:(NSError *__autoreleasing *)error
{
    //: if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (![self error:(NSHTTPURLResponse *)response duringData:data folly:error]) {
        //: if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        if (!error || singleDomain(*error, NSURLErrorCannotDecodeContentData, kKeepPolicySettings(nil))) {
            //: return nil;
            return nil;
        }
    }


    //: if (self.automaticallyInflatesResponseImage) {
    if (self.volumeBorderred) {
        //: return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale);
        return addressJoin((NSHTTPURLResponse *)response, data, self.tabDoed);
    //: } else {
    } else {
        //: return AFImageWithDataAtScale(data, self.imageScale);
        return secondInfo(data, self.tabDoed);
    }
    //: return nil;
    return nil;
}

//: @end
@end

//: #pragma mark -
#pragma mark -

//: @interface AFCompoundResponseSerializer ()
@interface HappyResponseSerializer ()
//: @property (readwrite, nonatomic, copy) NSArray *responseSerializers;
@property (readwrite, nonatomic, copy) NSArray *countryOpinioning;
@property (readwrite, nonatomic, copy) NSArray *additionalOpinioning;
//: @end
@end

//: @implementation AFCompoundResponseSerializer
@implementation HappyResponseSerializer

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: self = [super initWithCoder:decoder];
    self = [super initWithCoder:decoder];
	[self setCountryOpinioning:_additionalOpinioning];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: NSSet *classes = [NSSet setWithArray:@[[NSArray class], [AFHTTPResponseSerializer <AFURLResponseSerialization> class]]];
    NSSet *classes = [NSSet setWithArray:@[[NSArray class], [ReaderVolume <MethodSerialization> class]]];
    //: self.responseSerializers = [decoder decodeObjectOfClasses:classes forKey:NSStringFromSelector(@selector(responseSerializers))];
    self.additionalOpinioning = [decoder decodeObjectOfClasses:classes forKey:NSStringFromSelector(@selector(additionalOpinioning))];

    //: return self;
    return self;
}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFCompoundResponseSerializer *serializer = [super copyWithZone:zone];
    HappyResponseSerializer *serializer = [super copyWithZone:zone];
    //: serializer.responseSerializers = self.responseSerializers;
    serializer.additionalOpinioning = self.additionalOpinioning;
	[self setCountryOpinioning:_additionalOpinioning];

    //: return serializer;
    return serializer;
}

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [super encodeWithCoder:coder];
    [super encodeWithCoder:coder];

    //: [coder encodeObject:self.responseSerializers forKey:NSStringFromSelector(@selector(responseSerializers))];
    [coder encodeObject:[self liftEdit:self.additionalOpinioning] forKey:NSStringFromSelector(@selector(additionalOpinioning))];
}

//: #pragma mark - AFURLResponseSerialization
#pragma mark - MethodSerialization

//: - (id)responseObjectForResponse:(NSURLResponse *)response
- (id)allError:(NSURLResponse *)response
                           //: data:(NSData *)data
                           runningBucket:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          responseError:(NSError *__autoreleasing *)error
{
    //: for (id <AFURLResponseSerialization> serializer in self.responseSerializers) {
    for (id <MethodSerialization> serializer in [self liftEdit:self.additionalOpinioning]) {
        //: if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) {
        if (![serializer isKindOfClass:[ReaderVolume class]]) {
            //: continue;
            continue;
        }

        //: NSError *serializerError = nil;
        NSError *serializerError = nil;
        //: id responseObject = [serializer responseObjectForResponse:response data:data error:&serializerError];
        id responseObject = [serializer allError:response runningBucket:data responseError:&serializerError];
        //: if (responseObject) {
        if (responseObject) {
            //: if (error) {
            if (error) {
                //: *error = AFErrorWithUnderlyingError(serializerError, *error);
                *error = errorEhBloomerTiming(serializerError, *error);
            }

            //: return responseObject;
            return responseObject;
        }
    }

    //: return [super responseObjectForResponse:response data:data error:error];
    return [super allError:response runningBucket:data responseError:error];
}

- (NSArray *)liftEdit:(NSArray *)countryOpinioning {
    //: OC_CUSTOM_PROPERTY_INJECT
    _countryOpinioning = countryOpinioning;
    return countryOpinioning;
}

//: + (instancetype)compoundSerializerWithResponseSerializers:(NSArray *)responseSerializers {
+ (instancetype)originalSerializers:(NSArray *)responseSerializers {
    //: AFCompoundResponseSerializer *serializer = [[self alloc] init];
    HappyResponseSerializer *serializer = [[self alloc] init];
    //: serializer.responseSerializers = responseSerializers;
    serializer.additionalOpinioning = responseSerializers;

    //: return serializer;
    return serializer;
}

//: @end

- (void)setCountryOpinioning:(NSArray *)countryOpinioning {
    //: OC_CUSTOM_PROPERTY_INJECT
    _countryOpinioning = countryOpinioning;
}


@end
//: __SAVE__ ignore_string [1184.11,627.6,515.5,425.4]